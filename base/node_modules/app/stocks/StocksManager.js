import Stock from 'app/stocks/Stock';
import StockPosition from 'app/stocks/StockPosition';
import StocksHistory from 'app/repository/StocksHistory';
import MathUtils from 'app/service/MathUtils';
import Interval from 'app/service/Interval';
import StocksSymbols from 'app/service/StocksSymbols'

export default class StocksManager
{
    // static limits = {counter: -1,limit: -1, oldLimit: 10000000};
    // static stocks = [
    //     //new Stock(StocksSymbols.APPL),
    //     new Stock(StocksSymbols.MSFT)
    // ];
    //
    // static async start(step,limit = -1,clock)
    // {
    //
    //     if(limit===-1) {
    //       limit = 900719925474099;
    //     }
    //
    //     let counter = 0;
    //     while (counter < limit) {
    //         console.log('cycle: ',new Date());
    //         StocksManager.limits = {counter: counter,limit: limit, oldLimit: 10000000};
    //         //console.log('counter: ',counter,limit);
    //         //if( (limit >= 0) && (counter > limit)) break;
    //         await Interval.sleep(Math.floor(step),clock);
    //         //console.log('5 seconds passed now getting stock price');
    //         await StocksManager.updateAllStocks();
    //         counter++;
    //
    //     }
    // }
    //
    //
    //
    // static async updateAllStocks()
    // {
    //
    //     let temp = (stock,realPrice)=> {
    //         realPrice = MathUtils.round(realPrice);
    //         //consoleF.log('price: ',realPrice);
    //         if(StocksHistory.histories[stock.symbol]===undefined) {
    //             StocksHistory.histories[stock.symbol] = [];
    //         }
    //         let rand = Number((Math.random()*5).toFixed(2))-2.5;
    //         rand = 0;
    //         let nowTimeInSeconds = Number(((new Date().getTime())/1000).toFixed(2));
    //         stock.price = MathUtils.round(realPrice + rand);
    //         StocksHistory.histories[stock.symbol].push({time:nowTimeInSeconds,price:stock.price});
    //         //console.log( 'StocksHistory.histories: ',StocksHistory.histories);
    //         //console.log('GOT Price: ',stock);
    //     };
    //     for(let stock of StocksManager.stocks) {
    //
    //         //let realPrice =  await stock.getCurrentPrice();
    //         let realPrice = await stock.getCurrentPrice();
    //         temp(stock,realPrice);
    //
    //     }
    //
    //
    //
    //     return true;
    // }
    //
    // static async wait5Seconds()
    // {
    //     return new Promise((resolve)=>{
    //         setTimeout(()=> {
    //             resolve();
    //         }, 3000);
    //     });
    // }
    //
    // /**
    //  *
    //  * @param {StockPosition} stockPosition
    //  */
    // static sellPosition(stockPosition) {
    //     let totalValue = StocksManager.getStock(stockPosition.symbol).price*stockPosition.amount;
    //     return totalValue;
    // }
    //
    //
    //
    // /**
    //  *
    //  * @param symbol
    //  * @return {Stock}
    //  */
    // static getStock(symbol){
    //     let foundStock = null;
    //     StocksManager.stocks.forEach((stock)=>{
    //         if(stock.symbol === symbol) {
    //             foundStock = stock;
    //         }
    //     });
    //     return foundStock;
    // }
    //
    //
    // static buy1000(symbol) {
    //     let stock = StocksService.getStock(symbol);
    //     return new StockPosition(new Date().getTime(),stock.price,1000/stock.price,stock.symbol);
    // }
}

// RUNS for each stock (Runs once, maybe runs again after stocks are sold)
// Sensor Read stock price to some memory cell
// algorithm runs and decide to buy of not to buy. put the decision in memory sell
// checking a cell if to buy or not to buy and sped energy
// after half and hour sell the stock and get the extra energy or loss based on the price change
