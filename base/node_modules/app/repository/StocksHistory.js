// To be used by the loadStock sensor (first int is the memory destination second in is memory block that hold the time in seconds. for when to pull the stock data)
import HistoryLine from 'app/entity/HistoryLine'
import StocksSymbols from 'app/service/StocksSymbols'
export default class StocksHistory
{

    static STOCK_SEARCH_ACCURACY = 240;

    static instance = null;
    // Just for search

    histories = {

    };

    verifyTimeSync(symbol,baseTime)
    {
        let currentAlphaTime = this.histories[symbol][0].time;
        let margin = Math.abs(baseTime-currentAlphaTime);
        if( margin > StocksHistory.STOCK_SEARCH_ACCURACY) {
            throw new Error('Time is not synced: ' + baseTime + ' ' +currentAlphaTime + ' ' +StocksHistory.STOCK_SEARCH_ACCURACY +' ' +margin)
        }
    }


    /**
     *
     * @return {StocksHistory}
     */
    static getInstance()
    {
        if(StocksHistory.instance === null) {
            StocksHistory.instance = new StocksHistory();
        }
        return StocksHistory.instance;
    }

    clearStock(symbol)
    {
        this.histories[symbol] = [];
    }

    /**
     *
     * @param symbol
     * @return {HistoryLine}
     */
    lastLine(symbol)
    {
        return this.histories[symbol][this.histories[symbol].length - 1]
    }


    /**
     *
     * @param {HistoryLine}  historyLine
     */
    add(historyLine)
    {
        this.histories[historyLine.symbol].push(historyLine);
    }

    _add(symbol,timeInSeconds,price)
    {
        this.histories[symbol].push({'time': timeInSeconds, 'price': price});
    }

    /**
     *
     * @param symbol
     * @param baseTime
     * @param count
     * @param step
     * @return {HistoryLine[]}
     */
    getLastsBySteps(symbol,baseTime,count,step)
    {
        let accuracy = StocksHistory.STOCK_SEARCH_ACCURACY;
        let lasts = [];
        for(let i = 0;i < count; i++) {
            let historyLine = this.find(symbol,baseTime-i*step);
            lasts.push(historyLine);
        }

        return lasts;
    }

    // last6by5Old(symbol,baseTime)
    // {
    //     let step = 5*60;
    //     let count = 6;
    //
    //
    //     let lines = this.getLastsBySteps(symbol,baseTime,count,step);
    //     //this.verifyLast6By5(lines);
    //     return lines;
    // }

    last6by5(symbol,baseTime)
    {
        this.verifyTimeSync(symbol,baseTime);
        let lines = this.histories[symbol];
        let sixLines = [];
        for(let i = 0; i < 6 ; i++) {
            let selectedLine = lines[i*5];
            if(!selectedLine) {
                throw new Error('Problem with selected line: '+ i);
            }
            sixLines.push(selectedLine);
        }
        this.verifyLast6By5(sixLines);
        return sixLines;
    }

    /**
     *
     * @param {HistoryLine[]} lines
     */
    verifyLast6By5(lines)
    {
        if(lines.length!==6) {
            throw new Error('verifyLast6By5 length must be 6 got: '+lines.length);
        }
        let validLines = lines.filter((historyLine)=>{
            return (historyLine !== undefined) && (historyLine !== null)
        });

        if(validLines.length!==6) {
            throw new Error('verifyLast6By5 validResults length must be 6');
        }

        let verifiedLinesCounter = 0;
        let prevLine = validLines[0];
        for(let i = 1;i < 5;i++) {
            let currentLine = validLines[i];

            if( (prevLine.time - currentLine.time)>50*6*2) {
                console.log('verifyLast6By5 e1:',new Date());
                console.log('-------------------------');
                console.log('verifyLast6By5 e2:',currentLine,prevLine);
                console.log('verifyLast6By5 e3 time:',prevLine.time,currentLine.time);
                console.log('verifyLast6By5 e4 delta:',prevLine.time - currentLine.time);
                console.log('!!!!!!!!!!!!!!!!!!!!!!!!!');
                console.log('verifyLast6By5 e5:',lines);
                console.log('verifyLast6By5 delta :',prevLine.time - currentLine.time);
                throw new Error('verifyLast6By5 e6:',new Date());

            } else {
                verifiedLinesCounter++;
            }

            prevLine = currentLine;
        }
        return verifiedLinesCounter;

    }




    /**
     *
     * @param {HistoryLine[]} lines
     * @param {Number} targetUtcTime
     */
    static sortByNearestTime(targetUtcTime,lines)
    {
        return lines.concat().sort(StocksHistory.createCompareMethod(targetUtcTime));
    }

    /**
     *
     * @param symbol
     * @param utcTime
     * @return {HistoryLine|Null}
     */
    nearest(symbol,utcTime)
    {
        if(!(this.histories[symbol])) {return null};
        let sortedLines = StocksHistory.sortByNearestTime(utcTime,this.histories[symbol]);
        if(sortedLines.length === 0) {return null;}
        return sortedLines[0];
    }




    /**
     * Should return -1 if a is neared to utcTime
     * or 1 If b is nearer to utcTime
     * @param utcTime
     * @return {Function}
     */
    static createCompareMethod(utcTime) {
        return function (a,b) {
            let a_d = Math.abs(a.time - utcTime);
            let b_d = Math.abs(b.time - utcTime);
            if(isNaN(a_d)) throw new Error('compare Method a_d isNaN');
            if(isNaN(b_d)) throw new Error('compare Method b_d isNaN');
            //console.log('a_d: ',a_d,'b_d: ',b_d,'utcTime: ',utcTime);
            if( (a_d-b_d) < 0) {
                return -1;
            } if( (a_d-b_d) > 0) {
                return 1;
            } else if( (a_d-b_d) === 0) {
                return 0;
            } else {
                throw new Error('Something bad happened at compare method')
            }
        }
    }

    /**
     *
     * @param symbol
     * @param utcTime
     * @param delta
     * @return {HistoryLine}
     */
    find(symbol,utcTime)
    {
        let nearest = this.nearest(symbol,utcTime);
        if(!nearest) return null;
        if(!(nearest.isWithinTimeRange(utcTime,StocksHistory.STOCK_SEARCH_ACCURACY))) return null;
        return nearest;
    }

    // /**
    //  *
    //  * @param symbol
    //  * @return {HistoryLine}
    //  */
    // findCurrentOld(symbol)
    // {
    //     return this.find(symbol,(new Date().getTime())/1000)
    // }

    // @TODO need to test with time mocks
    /**
     *
     * @param symbol
     * @return {HistoryLine}
     */
    findCurrent(symbol)
    {
        let baseTime = Date.now()/1000;
        this.verifyTimeSync(symbol,baseTime);
        let lines = this.histories[symbol];
        let currentLine = lines[0];
        if(!currentLine) {
            console.log(lines);
            throw new Error('Problem in find current: '+baseTime)
        }
        return currentLine;
    }
}