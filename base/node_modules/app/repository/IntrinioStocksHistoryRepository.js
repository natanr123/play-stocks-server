// To be used by the loadStock sensor (first int is the memory destination second in is memory block that hold the time in seconds. for when to pull the stock data)
import HistoryLine from 'app/entity/HistoryLine'
import HistoryLineIntrinio from 'app/entity/HistoryLineIntrinio'

import StocksSymbols from 'app/service/StocksSymbols'
import Repository from 'app/repository/Repository'
import Entity from 'app/entity/Entity'
import MyDB from 'app/MyDB'
import TimeUtils from 'app/service/TimeUtils'

export default class IntrinioStocksHistoryRepository extends Repository
{
    static STOCK_SEARCH_ACCURACY = 500;
    static instance = null;

    maxSize = 8000;

    countCache = 0;

    static getInstance():IntrinioStocksHistoryRepository
    {
        if(IntrinioStocksHistoryRepository.instance === null) {
            IntrinioStocksHistoryRepository.instance = new IntrinioStocksHistoryRepository();
        }
        return IntrinioStocksHistoryRepository.instance;
    }

    add(historyLine:HistoryLine)
    {
        let count = this.count();
        if(count === this.maxSize) {
            this.removeFirst();
        } else {
        }
        this.countCache++;
        Entity.addToDB(historyLine);

    }

    removeFirst()
    {
        this.countCache--;
        let all = this.all();
        if(!(all[0])) {
            throw new Error('getFirst Error');
        }
        MyDB.getInstance().unset(this.firstResult().id)
    }

    isSync()
    {
        return MyDB.getInstance().allByClass(HistoryLineIntrinio);
    }

    firstResult():HistoryLineIntrinio {

        let all = this.all();
        let count = all.length;
        if(count === 0) {
            throw new Error('lastResult count < 0: '+ count);
        }
        return all[0];
    }

    lastResult():HistoryLineIntrinio {

        let all = this.all();
        let count = all.length;
        if(count === 0) {
            throw new Error('lastResult count < 0: '+ count);
        }
        return all[count-1];
    }

    verifyTimeSync(symbol,baseTime)
    {
        let currentAlphaTime = this.lastResult().time;
        let margin = Math.abs(baseTime-currentAlphaTime);
        if(isNaN(margin)) {
            console.log('verifyTimeSync margin is not a number',currentAlphaTime,baseTime);
            throw new Error('verifyTimeSync margin is not a number');
        }
        if( margin > IntrinioStocksHistoryRepository.STOCK_SEARCH_ACCURACY) {
            throw new Error('Intrinio Time is not synced: ' + baseTime + ' ' +currentAlphaTime + ' ' +IntrinioStocksHistoryRepository.STOCK_SEARCH_ACCURACY +' ' +margin)
        }
    }

    last6by5(symbol,baseTime)
    {
        this.verifyTimeSync(symbol,baseTime);
        let step = 5*60;
        let count = 6;


        let lines = this.getLastsBySteps(symbol,baseTime,count,step);
        //this.verifyLast6By5(lines);
        return lines;
    }

    static createCompareMethod(utcTime) {
        return function (a,b) {
            let a_d = Math.abs(a.time - utcTime);
            let b_d = Math.abs(b.time - utcTime);
            if(isNaN(a_d)) throw new Error('compare Method a_d isNaN');
            if(isNaN(b_d)) throw new Error('compare Method b_d isNaN');
            //console.log('a_d: ',a_d,'b_d: ',b_d,'utcTime: ',utcTime);
            if( (a_d-b_d) < 0) {
                return -1;
            } if( (a_d-b_d) > 0) {
                return 1;
            } else if( (a_d-b_d) === 0) {
                return 0;
            } else {
                throw new Error('Something bad happened at compare method')
            }
        }
    }

    static sortByNearestTime(targetUtcTime,lines)
    {
        return lines.concat().sort(IntrinioStocksHistoryRepository.createCompareMethod(targetUtcTime));
    }

    nearest(symbol,utcTime)
    {
        let lines = this.all();
        if(lines.length === 0) {
            throw new Error('There his to be at least one line')
        }
        if(!(lines)) {return null}
        let sortedLines = IntrinioStocksHistoryRepository.sortByNearestTime(utcTime,lines);
        if(sortedLines.length === 0) {return null;}
        return sortedLines[0];
    }

    find(symbol,utcTime)
    {
        let nearest = this.nearest(symbol,utcTime);
        if(!nearest) return null;
        if(!(nearest.isWithinTimeRange(utcTime,IntrinioStocksHistoryRepository.STOCK_SEARCH_ACCURACY))) return null;
        return nearest;
    }
    getLastsBySteps(symbol,baseTime,count,step)
    {
        let accuracy = IntrinioStocksHistoryRepository.STOCK_SEARCH_ACCURACY;
        let lasts = [];
        for(let i = 0;i < count; i++) {
            let historyLine = this.find(symbol,baseTime-i*step);
            lasts.push(historyLine);
        }

        return lasts;
    }

    last6by5(symbol,baseTime)
    {
        let step = 5*60;
        let count = 6;


        let lines = this.getLastsBySteps(symbol,baseTime,count,step);
        //this.verifyLast6By5(lines);
        return lines;
    }

    findCurrent(symbol,baseTime)
    {
        this.verifyTimeSync(symbol,baseTime);
        let currentLine = this.lastResult();
        if(!currentLine) {
            throw new Error('Intrinio Problem in find current: ' + baseTime)
        }
        return currentLine;
    }


    all():Array<HistoryLineIntrinio>
    {
        return MyDB.getInstance().allByClass(HistoryLineIntrinio);
    }

    fullCount()
    {
        return IntrinioStocksHistoryRepository.getInstance().all().length;
    }

    count()
    {
        return this.countCache;
        //return IntrinioStocksHistoryRepository.getInstance().all().length;
    }
}