import IntrinioRealtime from 'intrinio-realtime'

import Engine from 'app/engine/Engine'
import Entity from 'app/entity/Entity'
import HistoryLineIntrinio from 'app/entity/HistoryLineIntrinio'
import TimeUtils from 'app/service/TimeUtils'
import IntrinioStocksHistoryRepository from 'app/repository/IntrinioStocksHistoryRepository'
import File from 'app/service/File'
import Rx from 'rxjs/Rx'
import MathUtils from 'app/service/MathUtils';

import MyDB from 'app/MyDB'


// @TODO trim results older than 100 minutes ago so not getting huge data base
// @TODO throw exception if DataBase become hughes
export default class FakeIntrinioEngine extends Engine
{
    static counter = 0;
    static balancesCSV:File;
    static MAX_TIME_DELTA = 200;
    static prevPrice = null;

    static quoteToHistoryLine(quote) {
        let { ticker, type, price, size, timestamp } = quote;
        return new HistoryLineIntrinio(timestamp,price,ticker,null,size);
    }

    static onQuote(quote) {
        let { ticker, type, price, size, timestamp } = quote;

        if(type === 'last') {
            let count = IntrinioStocksHistoryRepository.getInstance().count();
            if(count > 20000) {
                throw new Error('Too much lines: ' + count);
            }
            let historyLine = FakeIntrinioEngine.quoteToHistoryLine(quote);
            let add = 0;
            if(Math.abs(TimeUtils.timeNowUtc()-timestamp)<FakeIntrinioEngine.MAX_TIME_DELTA) {
                add = 1;
                IntrinioStocksHistoryRepository.getInstance().add(historyLine);
            }
            FakeIntrinioEngine.balancesCSV.appendCSVLine([timestamp,Math.round(TimeUtils.timeNowUtc()),TimeUtils.timeInNewYork(new Date()),price,add])


        }
    }

    static onOldQuote(quote) {
        let { ticker, type, price, size, timestamp } = quote;

        if(type === 'last') {
            let count = IntrinioStocksHistoryRepository.getInstance().count();
            if(count > 20000) {
                throw new Error('Too much lines: ' + count);
            }
            let historyLine = FakeIntrinioEngine.quoteToHistoryLine(quote);
            let add = 0;
            add = 1;
            IntrinioStocksHistoryRepository.getInstance().add(historyLine);

            FakeIntrinioEngine.balancesCSV.appendCSVLine([timestamp,Math.round(TimeUtils.timeNowUtc()),TimeUtils.timeInNewYork(new Date()),price,add])


        }
    }

    //trimOld


    static async start()
    {
        console.log('STARTING ENGINE: ','FakeIntrinioEngine' );

        FakeIntrinioEngine.balancesCSV = await File.createBlank('./out_data/quests_fake_'+Math.round(TimeUtils.timeNowUtc())+'.csv');
        FakeIntrinioEngine.balancesCSV = await File.createBlank('./out_data/fake_records_'+Math.round(TimeUtils.timeNowUtc())+'.csv');
        await FakeIntrinioEngine.balancesCSV.appendCSVLine(['quoteTime','timeUTC','timeNY','price','add']);




        //emit value in sequence every 1 second
        const source = Rx.Observable.interval(10*1000);
        const subscribe = source.subscribe(val => {
            let price = FakeIntrinioEngine.getFakePrice();
            FakeIntrinioEngine.onQuote({ticker: 'MSFT', type: 'last', size: 200, price: price, timestamp: TimeUtils.timeNowUtc() })
        });



       for(let i = 200; i > 0; i--) {
           let price = FakeIntrinioEngine.getFakePrice();
           FakeIntrinioEngine.onOldQuote({ticker: 'MSFT', type: 'last', size: 200, price: price, timestamp: TimeUtils.timeNowUtc() - i*60 })
       }
    }

    static getFakePrice() {
        FakeIntrinioEngine.counter++;
        let basePrice = 50;
        if(FakeIntrinioEngine.prevPrice === null) {
            FakeIntrinioEngine.prevPrice = basePrice;
        }

        let r = FakeIntrinioEngine.prevPrice*1.001;
        FakeIntrinioEngine.prevPrice = r;

        // -0.5 for up and downs
        return MathUtils.round2(r);
    }
}